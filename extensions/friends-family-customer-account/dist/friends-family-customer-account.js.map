{
  "version": 3,
  "sources": ["../../../../node_modules/preact/src/constants.js", "../../../../node_modules/preact/src/util.js", "../../../../node_modules/preact/src/options.js", "../../../../node_modules/preact/src/create-element.js", "../../../../node_modules/preact/src/component.js", "../../../../node_modules/preact/src/diff/props.js", "../../../../node_modules/preact/src/create-context.js", "../../../../node_modules/preact/src/diff/children.js", "../../../../node_modules/preact/src/diff/index.js", "../../../../node_modules/preact/src/render.js", "../../../../node_modules/preact/src/clone-element.js", "../../../../node_modules/preact/src/diff/catch-error.js", "../../../../node_modules/preact/hooks/src/index.js", "../../../../node_modules/@preact/signals-core/src/index.ts", "../../../../node_modules/@preact/signals/src/index.ts", "../../../../node_modules/@shopify/ui-extensions/build/esm/preact.mjs", "../../../../node_modules/preact/jsx-runtime/src/utils.js", "../../../../node_modules/preact/src/constants.js", "../../../../node_modules/preact/jsx-runtime/src/index.js", "../../../../extensions/friends-family-customer-account/src/ProfileBlock.jsx", "<stdin>"],
  "sourceRoot": "/Users/julianmartel/appointment/shopify-friends-family-app/extensions/friends-family-customer-account/src",
  "sourcesContent": ["/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\t\toldVNode._dom = oldVNode._parent = null;\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\t\tconst lowerCaseName = name.toLowerCase();\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (lowerCaseName in dom || name == 'onFocusOut' || name == 'onFocusIn')\n\t\t\tname = lowerCaseName.slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tlet shouldPlace = !!(childVNode._flags & INSERT_VNODE);\n\t\tif (shouldPlace || oldVNode._children === childVNode._children) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom, shouldPlace);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor == UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @param {boolean} shouldPlace\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom, shouldPlace) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom, shouldPlace);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (shouldPlace) {\n\t\t\tif (oldDom && parentVNode.type && !oldDom.parentNode) {\n\t\t\t\toldDom = getDomSibling(parentVNode);\n\t\t\t}\n\t\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\t}\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\tconst matched = oldVNode != NULL && (oldVNode._flags & MATCHED) == 0;\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren > (matched ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && childVNode.key == null) ||\n\t\t(matched && key == oldVNode.key && type == oldVNode.type)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tconst childIndex = x >= 0 ? x-- : y++;\n\t\t\toldVNode = oldChildren[childIndex];\n\t\t\tif (\n\t\t\t\toldVNode != NULL &&\n\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\tkey == oldVNode.key &&\n\t\t\t\ttype == oldVNode.type\n\t\t\t) {\n\t\t\t\treturn childIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor != UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original == oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t\tmarkAsForce(newVNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\tif (!e.then) markAsForce(newVNode);\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\nfunction markAsForce(vnode) {\n\tif (vnode && vnode._component) vnode._component._force = true;\n\tif (vnode && vnode._children) vnode._children.forEach(markAsForce);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\n// We take the minimum timeout for requestAnimationFrame to ensure that\n// the callback is invoked after the next frame. 35ms is based on a 30hz\n// refresh rate, which is the minimum rate for a smooth user experience.\nconst RAF_TIMEOUT = 35;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *              \n\t\t *        tail  node (new)\n\t\t *               \n\t\t * { A <-> B <-> C }\n\t\t *               \n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *                    \n\t\t *        node    tail (evalContext._sources)\n\t\t *         \n\t\t *                    \n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     \n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T, options?: SignalOptions<T>);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\t/** @internal */\n\t_watched?(this: Signal<T>): void;\n\n\t/** @internal */\n\t_unwatched?(this: Signal<T>): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tname?: string;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\nexport interface SignalOptions<T = any> {\n\twatched?: (this: Signal<T>) => void;\n\tunwatched?: (this: Signal<T>) => void;\n\tname?: string;\n}\n\n/** @internal */\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\nfunction Signal(this: Signal, value?: unknown, options?: SignalOptions) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tconst targets = this._targets;\n\tif (targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = targets;\n\t\tthis._targets = node;\n\n\t\tif (targets !== undefined) {\n\t\t\ttargets._prevTarget = node;\n\t\t} else {\n\t\t\tuntracked(() => {\n\t\t\t\tthis._watched?.call(this);\n\t\t\t});\n\t\t}\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t\tif (next === undefined) {\n\t\t\t\tuntracked(() => {\n\t\t\t\t\tthis._unwatched?.call(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(\n\t\t() => {\n\t\t\tconst value = this.value;\n\t\t\tconst prevContext = evalContext;\n\t\t\tevalContext = undefined;\n\t\t\ttry {\n\t\t\t\tfn(value);\n\t\t\t} finally {\n\t\t\t\tevalContext = prevContext;\n\t\t\t}\n\t\t},\n\t\t{ name: \"sub\" }\n\t);\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T, options?: SignalOptions<T>): Signal<T> {\n\treturn new Signal(value, options);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tif (\n\t\t\t// If the dependency has definitely been updated since its version number\n\t\t\t// was observed, then we need to recompute. This first check is not strictly\n\t\t\t// necessary for correctness, but allows us to skip the refresh call if the\n\t\t\t// dependency has already been updated.\n\t\t\tnode._source._version !== node._version ||\n\t\t\t// Refresh the dependency. If there's something blocking the refresh (e.g. a\n\t\t\t// dependency cycle), then we need to recompute.\n\t\t\t!node._source._refresh() ||\n\t\t\t// If the dependency got a new version after the refresh, then we need to recompute.\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                              \n\t *                              \n\t * target._sources = A; (node is head)  \n\t *                                     \n\t * target._sources = C; (node is tail) \n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head: Node | undefined = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         \n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *             \n\t\t\t *              head = node\n\t\t\t *         head = node\n\t\t\t *    head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\n/**\n * The base class for computed signals.\n */\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T, options?: SignalOptions<T>);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\n/** @internal */\nfunction Computed(this: Computed, fn: () => unknown, options?: SignalOptions) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(\n\tfn: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\treturn new Computed(fn, options);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn =\n\t| ((this: { dispose: () => void }) => void | (() => void))\n\t| (() => void | (() => void));\n\n/**\n * The base class for reactive effects.\n */\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\tname?: string;\n\n\tconstructor(fn: EffectFn, options?: EffectOptions);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n\tdispose(): void;\n}\n\nexport interface EffectOptions {\n\tname?: string;\n}\n\n/** @internal */\nfunction Effect(this: Effect, fn: EffectFn, options?: EffectOptions) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n\tthis.name = options?.name;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nEffect.prototype.dispose = function () {\n\tthis._dispose();\n};\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn, options?: EffectOptions): () => void {\n\tconst effect = new Effect(fn, options);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\tconst dispose = effect._dispose.bind(effect);\n\t(dispose as any)[Symbol.dispose] = dispose;\n\treturn dispose as any;\n}\n\nexport {\n\tcomputed,\n\teffect,\n\tbatch,\n\tuntracked,\n\tSignal,\n\tReadonlySignal,\n\tEffect,\n\tComputed,\n};\n", "import { options, Component, isValidElement, Fragment } from \"preact\";\nimport { useRef, useMemo, useEffect, useState } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n\tSignalOptions,\n\tEffectOptions,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\nlet oldNotify: (this: Effect) => void,\n\teffectsQueue: Array<Effect> = [],\n\tdomQueue: Array<Effect> = [];\n\n// Capture the original `Effect.prototype._notify` method so that we can install\n// custom `._notify`s for each different use-case but still call the original\n// implementation in the end. Dispose the temporary effect immediately afterwards.\neffect(function (this: Effect) {\n\toldNotify = this._notify;\n})();\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction SignalValue(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst [isText, s] = useMemo(() => {\n\t\tlet self = this;\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst wrappedSignal = computed(() => {\n\t\t\tlet s = currentSignal.value.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\n\t\tconst isText = computed(\n\t\t\t() =>\n\t\t\t\t!Array.isArray(wrappedSignal.value) &&\n\t\t\t\t!isValidElement(wrappedSignal.value)\n\t\t);\n\t\t// Update text nodes directly without rerendering when the new value\n\t\t// is also text.\n\t\tconst dispose = effect(function (this: Effect) {\n\t\t\tthis._notify = notifyDomUpdates;\n\n\t\t\t// Subscribe to wrappedSignal updates only when its values are text...\n\t\t\tif (isText.value) {\n\t\t\t\t// ...but regardless of `self.base`'s current value, as it can be\n\t\t\t\t// undefined before mounting or a non-text node. In both of those cases\n\t\t\t\t// the update gets handled by a full rerender.\n\t\t\t\tconst value = wrappedSignal.value;\n\t\t\t\tif (self.__v && self.__v.__e && self.__v.__e.nodeType === 3) {\n\t\t\t\t\t(self.__v.__e as Text).data = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Piggyback this._updater's disposal to ensure that the text updater effect\n\t\t// above also gets disposed on unmount.\n\t\tconst oldDispose = this._updater!._dispose;\n\t\tthis._updater!._dispose = function () {\n\t\t\tdispose();\n\t\t\toldDispose.call(this);\n\t\t};\n\n\t\treturn [isText, wrappedSignal];\n\t}, []);\n\n\t// Rerender the component whenever `data.value` changes from a VNode\n\t// to another VNode, from text to a VNode, or from a VNode to text.\n\t// That is, everything else except text-to-text updates.\n\t//\n\t// This also ensures that the backing DOM node types gets updated to\n\t// text nodes and back when needed.\n\t//\n\t// For text-to-text updates, `.peek()` is used to skip full rerenders,\n\t// leaving them to the optimized path above.\n\treturn isText.value ? s.peek() : s.value;\n}\n\nSignalValue.displayName = \"ReactiveTextNode\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true, value: undefined },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (\n\t\ttypeof vnode.type === \"function\" &&\n\t\ttypeof window !== \"undefined\" &&\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__\n\t) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.exitComponent();\n\t}\n\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tif (\n\t\ttypeof vnode.type === \"function\" &&\n\t\ttypeof window !== \"undefined\" &&\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__\n\t) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.enterComponent(vnode);\n\t}\n\n\t// Ignore the Fragment inserted by preact.createElement().\n\tif (vnode.type !== Fragment) {\n\t\tsetCurrentUpdater();\n\n\t\tlet updater;\n\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\t\tupdater = component._updater;\n\t\t\tif (updater === undefined) {\n\t\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\t\tcomponent.setState({});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tcurrentComponent = component;\n\t\tsetCurrentUpdater(updater);\n\t}\n\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tif (typeof window !== \"undefined\" && window.__PREACT_SIGNALS_DEVTOOLS__) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.exitComponent();\n\t}\n\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tif (\n\t\ttypeof vnode.type === \"function\" &&\n\t\ttypeof window !== \"undefined\" &&\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__\n\t) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.exitComponent();\n\t}\n\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(function (this: Effect) {\n\t\t\tthis._notify = notifyDomUpdates;\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3 || type === 9)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// If this is a component using state, rerender\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\tif (this.__f || (typeof this.u == \"boolean\" && this.u === true)) {\n\t\tconst hasHooksState = this._updateFlags & HAS_HOOK_STATE;\n\t\t// if this component used no signals or computeds and no hooks state, update:\n\t\tif (!hasSignals && !hasHooksState && !(this._updateFlags & HAS_COMPUTEDS))\n\t\t\treturn true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & HAS_PENDING_UPDATE) return true;\n\t} else {\n\t\t// if this component used no signals or computeds, update:\n\t\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\t}\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T, options?: SignalOptions<T>) {\n\treturn useState(() =>\n\t\tsignal<T | undefined>(value, options as SignalOptions)\n\t)[0];\n}\n\nexport function useComputed<T>(\n\tcompute: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\tconst [$fn, $computed] = useMemo(() => {\n\t\tconst $fn = signal(compute);\n\t\treturn [$fn, computed(() => $fn.value(), options)] as const;\n\t}, []);\n\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\t$fn.value = compute;\n\treturn $computed;\n}\n\nfunction safeRaf(callback: () => void) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tcancelAnimationFrame(raf);\n\t\tcallback();\n\t};\n\n\tconst timeout = setTimeout(done, 35);\n\tconst raf = requestAnimationFrame(done);\n}\n\nconst deferEffects =\n\ttypeof requestAnimationFrame === \"undefined\" ? setTimeout : safeRaf;\n\nconst deferDomUpdates = (cb: any) => {\n\tqueueMicrotask(() => {\n\t\tqueueMicrotask(cb);\n\t});\n};\n\nfunction flushEffects() {\n\tbatch(() => {\n\t\tlet inst: Effect | undefined;\n\t\twhile ((inst = effectsQueue.shift())) {\n\t\t\toldNotify.call(inst);\n\t\t}\n\t});\n}\n\nfunction notifyEffects(this: Effect) {\n\tif (effectsQueue.push(this) === 1) {\n\t\t(options.requestAnimationFrame || deferEffects)(flushEffects);\n\t}\n}\n\nfunction flushDomUpdates() {\n\tbatch(() => {\n\t\tlet inst: Effect | undefined;\n\t\twhile ((inst = domQueue.shift())) {\n\t\t\toldNotify.call(inst);\n\t\t}\n\t});\n}\n\nfunction notifyDomUpdates(this: Effect) {\n\tif (domQueue.push(this) === 1) {\n\t\t(options.requestAnimationFrame || deferDomUpdates)(flushDomUpdates);\n\t}\n}\n\nexport function useSignalEffect(\n\tcb: () => void | (() => void),\n\toptions?: EffectOptions\n) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\tthis._notify = notifyEffects;\n\t\t\treturn callback.current();\n\t\t}, options);\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n", "import { Signal } from '@preact/signals';\n\nconst shopify = globalThis.shopify;\nif (shopify && typeof shopify.setSignals === 'function') {\n  shopify.setSignals(Signal);\n}\n", "const ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nexport function encodeEntities(str) {\n\t// Skip all work for strings with no entities needing encoding:\n\tif (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n\n\tlet last = 0,\n\t\ti = 0,\n\t\tout = '',\n\t\tch = '';\n\n\t// Seek forward in str until the next entity char:\n\tfor (; i < str.length; i++) {\n\t\tswitch (str.charCodeAt(i)) {\n\t\t\tcase 34:\n\t\t\t\tch = '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tch = '&amp;';\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\t\tch = '&lt;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\t// Append skipped/buffered characters and the encoded entity:\n\t\tif (i !== last) out += str.slice(last, i);\n\t\tout += ch;\n\t\t// Start the next seek/buffer after the entity's offset:\n\t\tlast = i + 1;\n\t}\n\tif (i !== last) out += str.slice(last, i);\n\treturn out;\n}\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in normalizedProps) {\n\t\tnormalizedProps = {};\n\t\tfor (i in props) {\n\t\t\tif (i == 'ref') {\n\t\t\t\tref = props[i];\n\t\t\t} else {\n\t\t\t\tnormalizedProps[i] = props[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Unwrap potential signals.\n * @param {*} value\n * @returns {*}\n */\nfunction normalizeAttrValue(value) {\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.valueOf === 'function'\n\t\t? value.valueOf()\n\t\t: value;\n}\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tvalue = normalizeAttrValue(value);\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t\t(JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + encodeEntities(str) + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities('' + value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n", "import '@shopify/ui-extensions/preact';\nimport {render} from \"preact\";\nimport {useState, useEffect, useRef} from 'preact/hooks';\n\nexport default async () => {\n  render(<FriendsFamilyBlock />, document.body);\n}\n\nconst APP_URL = 'https://shopify-friends-family-app.vercel.app';\n\nfunction FriendsFamilyBlock() {\n  const [groups, setGroups] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [canCreateGroups, setCanCreateGroups] = useState(false);\n  const [maxMembersPerGroup, setMaxMembersPerGroup] = useState(null);\n  const [showCreateForm, setShowCreateForm] = useState(false);\n  const [creatingGroup, setCreatingGroup] = useState(false);\n  const [createGroupError, setCreateGroupError] = useState(null);\n  const [inviteCode, setInviteCode] = useState('');\n  const [joiningGroup, setJoiningGroup] = useState(false);\n  const [joinError, setJoinError] = useState(null);\n  const [joinSuccess, setJoinSuccess] = useState(false);\n  \n  // Group details state\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  const [groupDetails, setGroupDetails] = useState(null);\n  const [loadingDetails, setLoadingDetails] = useState(false);\n  const [showInviteForm, setShowInviteForm] = useState(false);\n  const [inviteEmail, setInviteEmail] = useState('');\n  const [sendingInvite, setSendingInvite] = useState(false);\n  const [inviteError, setInviteError] = useState(null);\n  const [inviteSuccess, setInviteSuccess] = useState(false);\n  const [inviteManualCode, setInviteManualCode] = useState(null);\n  const [copyMessage, setCopyMessage] = useState(null);\n  const [removingMemberId, setRemovingMemberId] = useState(null);\n  const [removeError, setRemoveError] = useState(null);\n  const [removeSuccess, setRemoveSuccess] = useState(false);\n  const [revokingInvitationId, setRevokingInvitationId] = useState(null);\n  const [revokeInvitationError, setRevokeInvitationError] = useState(null);\n  const groupDetailsRefreshIntervalRef = useRef(null);\n  \n  // Form state\n  const [groupName, setGroupName] = useState('');\n\n  useEffect(() => {\n    fetchPermissions();\n    fetchGroups();\n    \n    // Cleanup interval on unmount\n    return () => {\n      if (groupDetailsRefreshIntervalRef.current) {\n        clearInterval(groupDetailsRefreshIntervalRef.current);\n      }\n    };\n  }, []);\n\n  async function fetchPermissions() {\n    try {\n      const sessionToken = await shopify.sessionToken.get();\n      const authenticatedAccount = shopify.authenticatedAccount;\n      const customer = authenticatedAccount?.customer?.value;\n      \n      let apiUrl = `${APP_URL}/api/customer/permissions`;\n      \n      if (customer?.id) {\n        const customerIdMatch = customer.id.match(/Customer\\/(\\d+)/);\n        if (customerIdMatch && customerIdMatch[1]) {\n          apiUrl += `?customerId=${customerIdMatch[1]}`;\n        }\n      }\n      \n      const response = await fetch(apiUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        setCanCreateGroups(data.canCreateGroups === true);\n        setMaxMembersPerGroup(data.maxMembersPerGroup || null);\n        console.log('[ProfileBlock] User permissions:', {\n          canCreateGroups: data.canCreateGroups,\n          maxMembersPerGroup: data.maxMembersPerGroup,\n        });\n      } else {\n        console.warn('[ProfileBlock] Could not fetch permissions, defaulting to false');\n        setCanCreateGroups(false);\n      }\n    } catch (err) {\n      console.error('[ProfileBlock] Error fetching permissions:', err);\n      setCanCreateGroups(false);\n    }\n  }\n\n  async function fetchGroups() {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      console.log('[ProfileBlock] Starting to fetch groups...');\n      \n      const authenticatedAccount = shopify.authenticatedAccount;\n      const customer = authenticatedAccount?.customer?.value;\n      console.log('[ProfileBlock] Authenticated account:', {\n        hasAccount: !!authenticatedAccount,\n        hasCustomer: !!customer,\n        customerId: customer?.id,\n      });\n      \n      let sessionToken;\n      try {\n        sessionToken = await shopify.sessionToken.get();\n        console.log('[ProfileBlock] Session token obtained, length:', sessionToken?.length || 0);\n      } catch (tokenError) {\n        console.error('[ProfileBlock] Error getting session token:', tokenError);\n        throw new Error('No se pudo obtener el token de sesi\u00F3n');\n      }\n      \n      if (!sessionToken) {\n        throw new Error('Token de sesi\u00F3n no disponible');\n      }\n      \n      \n      let apiUrl = `${APP_URL}/api/customer/group`;\n      if (customer?.id) {\n        const customerIdMatch = customer.id.match(/Customer\\/(\\d+)/);\n        if (customerIdMatch && customerIdMatch[1]) {\n          apiUrl += `?customerId=${customerIdMatch[1]}`;\n          console.log('[ProfileBlock] Using customer ID from authenticatedAccount:', customerIdMatch[1]);\n        }\n      }\n      \n      console.log('[ProfileBlock] Making request to:', apiUrl);\n      \n      const response = await fetch(apiUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n      });\n\n      console.log('[ProfileBlock] Response status:', response.status, response.statusText);\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('[ProfileBlock] API Error:', {\n          status: response.status,\n          statusText: response.statusText,\n          body: errorText,\n        });\n        \n        let errorMessage = 'Error al cargar grupos';\n        try {\n          const errorData = JSON.parse(errorText);\n          errorMessage = errorData.error || errorMessage;\n        } catch (e) {\n          errorMessage = errorText || errorMessage;\n        }\n        \n        throw new Error(errorMessage);\n      }\n\n      const data = await response.json();\n      console.log('[ProfileBlock] Success! Groups received:', data.groups?.length || 0);\n      setGroups(data.groups || []);\n    } catch (err) {\n      console.error('[ProfileBlock] Error fetching groups:', err);\n      setError(err.message || 'Error desconocido al cargar grupos');\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function fetchGroupDetails(groupId) {\n    try {\n      setLoadingDetails(true);\n      setError(null);\n      \n      const sessionToken = await shopify.sessionToken.get();\n      \n      const response = await fetch(`${APP_URL}/api/groups/${groupId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Error al cargar detalles del grupo');\n      }\n\n      const data = await response.json();\n      console.log('[ProfileBlock] Group details received:', {\n        hasGroup: !!data.group,\n        membersCount: data.members?.length || 0,\n        pendingInvitationsCount: data.pendingInvitations?.length || 0,\n        pendingInvitations: data.pendingInvitations,\n      });\n      setGroupDetails(data);\n    } catch (err) {\n      console.error('[ProfileBlock] Error fetching group details:', err);\n      setError(err.message || 'Error al cargar detalles del grupo');\n    } finally {\n      setLoadingDetails(false);\n    }\n  }\n\n  async function handleViewDetails(group) {\n    setSelectedGroup(group);\n    setShowInviteForm(false);\n    setInviteEmail('');\n    setInviteError(null);\n    setInviteSuccess(false);\n    setInviteManualCode(null);\n    setCopyMessage(null);\n    setRemoveError(null);\n    setRemoveSuccess(false);\n    setRemovingMemberId(null);\n    await fetchGroupDetails(group.id);\n    \n    // Auto-refresh group details every 10 seconds when viewing details\n    // This ensures we see new members who accepted invitations\n    if (groupDetailsRefreshIntervalRef.current) {\n      clearInterval(groupDetailsRefreshIntervalRef.current);\n    }\n    groupDetailsRefreshIntervalRef.current = setInterval(async () => {\n      if (group) {\n        console.log('[ProfileBlock] Auto-refreshing group details...');\n        await fetchGroupDetails(group.id);\n      }\n    }, 10000); // Refresh every 10 seconds\n  }\n\n  async function handleBackToList() {\n    // Clear refresh interval when leaving group details\n    if (groupDetailsRefreshIntervalRef.current) {\n      clearInterval(groupDetailsRefreshIntervalRef.current);\n      groupDetailsRefreshIntervalRef.current = null;\n    }\n    \n    setSelectedGroup(null);\n    setGroupDetails(null);\n    setShowInviteForm(false);\n    setInviteEmail('');\n    setInviteError(null);\n    setInviteSuccess(false);\n    setInviteManualCode(null);\n    setCopyMessage(null);\n    setRemoveError(null);\n    setRemoveSuccess(false);\n    setRemovingMemberId(null);\n    await fetchGroups(); // Refresh groups list\n  }\n  \n  async function handleRefreshGroupDetails() {\n    if (selectedGroup) {\n      await fetchGroupDetails(selectedGroup.id);\n    }\n  }\n\n  async function handleRevokeInvitation(invitationId) {\n    if (!selectedGroup || !invitationId) {\n      console.warn('[ProfileBlock] Cannot revoke invitation: missing selectedGroup or invitationId');\n      return;\n    }\n\n    console.log('[ProfileBlock] Revoking invitation:', { invitationId, groupId: selectedGroup.id });\n    setRevokingInvitationId(invitationId);\n    setRevokeInvitationError(null);\n\n    try {\n      const sessionToken = await shopify.sessionToken.get();\n      console.log('[ProfileBlock] Session token obtained, length:', sessionToken?.length || 0);\n      \n      const url = `${APP_URL}/api/invitations/revoke?id=${invitationId}`;\n      console.log('[ProfileBlock] Calling DELETE:', url);\n      \n      const response = await fetch(url, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n      });\n\n      console.log('[ProfileBlock] Response status:', response.status, response.statusText);\n      const data = await response.json();\n      console.log('[ProfileBlock] Response data:', data);\n\n      if (response.ok && data.success) {\n        console.log('[ProfileBlock] \u2705 Invitation revoked successfully');\n        // Reload group details to refresh the pending invitations list\n        await fetchGroupDetails(selectedGroup.id);\n        setRevokeInvitationError(null);\n      } else {\n        const errorMsg = data.error || 'Error al eliminar la invitaci\u00F3n';\n        console.error('[ProfileBlock] \u274C Error revoking invitation:', errorMsg);\n        setRevokeInvitationError(errorMsg);\n      }\n    } catch (err) {\n      console.error('[ProfileBlock] Exception revoking invitation:', err);\n      setRevokeInvitationError('Error al eliminar la invitaci\u00F3n. Intenta de nuevo.');\n    } finally {\n      setRevokingInvitationId(null);\n    }\n  }\n\n  async function handleInvite() {\n    if (!inviteEmail.trim()) {\n      setInviteError('Por favor ingresa un email v\u00E1lido');\n      return;\n    }\n\n    setSendingInvite(true);\n    setInviteError(null);\n    setInviteSuccess(false);\n\n    try {\n      const sessionToken = await shopify.sessionToken.get();\n      \n      const response = await fetch(`${APP_URL}/api/invitations`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n        body: JSON.stringify({\n          groupId: selectedGroup.id,\n          email: inviteEmail.trim(),\n        }),\n      });\n\n      const data = await response.json();\n\n      if (response.ok && data.invitation) {\n        // Check if email was sent successfully\n        if (data.emailSent) {\n          setInviteSuccess(true);\n          setInviteEmail('');\n          setInviteManualCode(null);\n          setCopyMessage(null);\n          // Reload group details to show the new pending invitation\n          await fetchGroupDetails(selectedGroup.id);\n          setTimeout(() => {\n            setInviteSuccess(false);\n            setShowInviteForm(false);\n          }, 3000);\n        } else {\n          // Invitation was created but email failed\n          const errorMsg = data.emailError || 'El email no pudo ser enviado, pero la invitaci\u00F3n fue creada.';\n          setInviteError(errorMsg);\n          setInviteManualCode(data.inviteCode || null);\n          setInviteSuccess(true);\n          // Reload group details to show the new pending invitation\n          await fetchGroupDetails(selectedGroup.id);\n        }\n      } else {\n        setInviteError(data.error || 'Error al enviar la invitaci\u00F3n');\n      }\n    } catch (err) {\n      console.error('[ProfileBlock] Error sending invitation:', err);\n      setInviteError('Error al enviar la invitaci\u00F3n. Intenta de nuevo.');\n    } finally {\n      setSendingInvite(false);\n    }\n  }\n\n  async function handleRemoveMember(memberId) {\n    if (!selectedGroup) {\n      return;\n    }\n\n    setRemoveError(null);\n    setRemoveSuccess(false);\n    setRemovingMemberId(memberId);\n\n    try {\n      const sessionToken = await shopify.sessionToken.get();\n\n      const response = await fetch(`${APP_URL}/api/groups/${selectedGroup.id}/members/${memberId}`, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        const data = await response.json().catch(() => ({}));\n        throw new Error(data.error || 'No se pudo eliminar al miembro');\n      }\n\n      setRemoveSuccess(true);\n      setTimeout(() => setRemoveSuccess(false), 3000);\n\n      await fetchGroupDetails(selectedGroup.id);\n      await fetchGroups();\n    } catch (err) {\n      console.error('[ProfileBlock] Error removing member:', err);\n      setRemoveError(err.message || 'No se pudo eliminar al miembro. Intenta de nuevo.');\n    } finally {\n      setRemovingMemberId(null);\n    }\n  }\n\n  async function createGroup() {\n    try {\n      setCreatingGroup(true);\n      setCreateGroupError(null);\n      \n      if (!groupName.trim()) {\n        setCreateGroupError('El nombre del grupo es requerido');\n        return;\n      }\n\n      // Check if user already has a group (limit to 1 group per user)\n      if (groups.length > 0) {\n        setCreateGroupError('Ya tienes un grupo activo. Solo puedes tener un grupo a la vez.');\n        return;\n      }\n      \n      const sessionToken = await shopify.sessionToken.get();\n      const authenticatedAccount = shopify.authenticatedAccount;\n      const customer = authenticatedAccount?.customer?.value;\n      \n      let apiUrl = `${APP_URL}/api/groups`;\n      \n      if (customer?.id) {\n        const customerIdMatch = customer.id.match(/Customer\\/(\\d+)/);\n        if (customerIdMatch && customerIdMatch[1]) {\n          apiUrl += `?customerId=${customerIdMatch[1]}`;\n        }\n      }\n      \n      const response = await fetch(apiUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n        body: JSON.stringify({\n          name: groupName.trim(),\n          merchantId: 'default',\n          // max_members is controlled by backend (user.max_members_per_group or config)\n        }),\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        let errorMessage = 'Error al crear el grupo';\n        try {\n          const errorData = JSON.parse(errorText);\n          errorMessage = errorData.error || errorMessage;\n        } catch (e) {\n          errorMessage = errorText || errorMessage;\n        }\n        throw new Error(errorMessage);\n      }\n      \n      const data = await response.json();\n      console.log('[ProfileBlock] Group created successfully:', data);\n      \n      setShowCreateForm(false);\n      setGroupName('');\n      \n      await fetchGroups();\n    } catch (err) {\n      console.error('[ProfileBlock] Error creating group:', err);\n      setCreateGroupError(err.message || 'Error desconocido al crear el grupo');\n    } finally {\n      setCreatingGroup(false);\n    }\n  }\n\n  async function joinGroupByCode() {\n    if (!inviteCode.trim()) {\n      setJoinError('Por favor ingresa un c\u00F3digo de invitaci\u00F3n');\n      return;\n    }\n\n    setJoiningGroup(true);\n    setJoinError(null);\n    setJoinSuccess(false);\n\n    try {\n      const sessionToken = await shopify.sessionToken.get();\n      \n      const response = await fetch(`${APP_URL}/api/invitations/join-by-code`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`,\n        },\n        credentials: 'include',\n        body: JSON.stringify({\n          inviteCode: inviteCode.trim().toUpperCase(),\n        }),\n      });\n\n      const data = await response.json();\n\n      if (response.ok && data.member) {\n        setInviteCode('');\n        setJoinSuccess(true);\n        await fetchGroups();\n      } else {\n        setJoinError(data.error || 'Error al unirse al grupo');\n      }\n    } catch (err) {\n      console.error('[ProfileBlock] Error joining group:', err);\n      setJoinError('Error al unirse al grupo. Intenta de nuevo.');\n    } finally {\n      setJoiningGroup(false);\n    }\n  }\n\n  async function copyInviteCode(code) {\n    if (!code) return;\n    try {\n      await navigator.clipboard?.writeText?.(code);\n      setCopyMessage('C\u00F3digo copiado al portapapeles');\n      setTimeout(() => setCopyMessage(null), 3000);\n    } catch (err) {\n      console.warn('[ProfileBlock] No se pudo copiar el c\u00F3digo:', err);\n      setCopyMessage('No se pudo copiar autom\u00E1ticamente. Copia manualmente.');\n      setTimeout(() => setCopyMessage(null), 5000);\n    }\n  }\n\n  if (loading) {\n    return (\n      <s-section heading=\"Friends & Family\">\n        <s-stack direction=\"block\" gap=\"base\">\n          <s-text>Cargando grupos...</s-text>\n        </s-stack>\n      </s-section>\n    );\n  }\n\n  if (error && !selectedGroup) {\n    return (\n      <s-section heading=\"Friends & Family\">\n        <s-banner tone=\"critical\">\n          <s-text>{error}</s-text>\n        </s-banner>\n      </s-section>\n    );\n  }\n\n  // Show group details view\n  if (selectedGroup && groupDetails) {\n    const group = groupDetails.group;\n    const members = groupDetails.members || [];\n    const pendingInvitations = groupDetails.pendingInvitations || [];\n    \n    // Debug log\n    console.log('[ProfileBlock] Rendering group details:', {\n      groupId: group?.id,\n      membersCount: members.length,\n      pendingInvitationsCount: pendingInvitations.length,\n      pendingInvitations: pendingInvitations,\n      groupDetailsKeys: Object.keys(groupDetails),\n    });\n    \n    return (\n      <s-section heading=\"Detalles del Grupo\">\n        <s-stack direction=\"block\" gap=\"base\">\n          <s-stack direction=\"inline\" gap=\"base\" justifyContent=\"space-between\">\n            <s-button \n              variant=\"secondary\" \n              onClick={handleBackToList}\n            >\n              \u2190 Volver a la lista\n            </s-button>\n            <s-button \n              variant=\"secondary\" \n              size=\"slim\"\n              onClick={handleRefreshGroupDetails}\n            >\n              \uD83D\uDD04 Actualizar\n            </s-button>\n          </s-stack>\n          \n          <s-stack direction=\"block\" gap=\"small\">\n            <s-heading>{group.name}</s-heading>\n            <s-badge tone={group.status === 'active' ? 'success' : 'attention'}>\n              {group.status === 'active' ? 'Activo' : group.status}\n            </s-badge>\n          </s-stack>\n          \n          <s-stack direction=\"block\" gap=\"small\">\n            <s-text>\n              <s-text type=\"strong\">Miembros:</s-text> {group.current_members} / {group.max_members}\n            </s-text>\n            \n            {group.invite_code && (\n              <s-text>\n                <s-text type=\"strong\">C\u00F3digo de invitaci\u00F3n:</s-text> {group.invite_code}\n              </s-text>\n            )}\n          </s-stack>\n\n          {removeSuccess && (\n            <s-banner tone=\"success\">\n              <s-text>Miembro eliminado correctamente.</s-text>\n            </s-banner>\n          )}\n\n          {removeError && (\n            <s-banner tone=\"critical\">\n              <s-text>{removeError}</s-text>\n            </s-banner>\n          )}\n          \n          {members.length > 0 && (\n            <s-stack direction=\"block\" gap=\"small\">\n              <s-heading>Miembros del Grupo</s-heading>\n              {members.map((member) => (\n                <s-stack\n                  key={member.id}\n                  direction=\"inline\"\n                  justifyContent=\"space-between\"\n                  alignItems=\"center\"\n                >\n                  <s-text>\n                    \u2022 {member.email} {member.role === 'owner' ? '(Propietario)' : ''}\n                  </s-text>\n                  {member.role !== 'owner' && (\n                    <s-button\n                      variant=\"secondary\"\n                      size=\"slim\"\n                      onClick={() => handleRemoveMember(member.id)}\n                      loading={removingMemberId === member.id}\n                      disabled={removingMemberId === member.id}\n                    >\n                      Quitar\n                    </s-button>\n                  )}\n                </s-stack>\n              ))}\n            </s-stack>\n          )}\n\n          {/* Debug info - mostrar siempre para verificar */}\n          <s-stack direction=\"block\" gap=\"small\">\n            <s-text tone=\"subdued\" size=\"small\">\n              Debug: pendingInvitations recibidas = {pendingInvitations.length}\n            </s-text>\n            {pendingInvitations.length > 0 && (\n              <s-text tone=\"subdued\" size=\"small\">\n                Emails: {pendingInvitations.map((inv) => inv.email).join(', ')}\n              </s-text>\n            )}\n          </s-stack>\n\n          {revokeInvitationError && (\n            <s-banner tone=\"critical\">\n              <s-text>{revokeInvitationError}</s-text>\n            </s-banner>\n          )}\n\n          {pendingInvitations.length > 0 && (\n            <s-stack direction=\"block\" gap=\"small\">\n              <s-heading>Invitaciones Pendientes ({pendingInvitations.length})</s-heading>\n              {pendingInvitations.map((invitation) => {\n                const expiresDate = new Date(invitation.expires_at);\n                const isExpiringSoon = expiresDate.getTime() - Date.now() < 24 * 60 * 60 * 1000; // Menos de 24 horas\n                \n                return (\n                  <s-stack\n                    key={invitation.id}\n                    direction=\"inline\"\n                    justifyContent=\"space-between\"\n                    alignItems=\"center\"\n                  >\n                    <s-stack direction=\"block\" gap=\"none\">\n                      <s-text>\n                        \u2022 {invitation.email}\n                      </s-text>\n                      <s-text tone=\"subdued\" size=\"small\">\n                        Enviada: {new Date(invitation.sent_at).toLocaleDateString('es-ES')}\n                        {isExpiringSoon && (\n                          <s-text tone=\"attention\"> \u2022 Expira pronto</s-text>\n                        )}\n                      </s-text>\n                    </s-stack>\n                    <s-button\n                      variant=\"secondary\"\n                      size=\"slim\"\n                      onClick={() => handleRevokeInvitation(invitation.id)}\n                      loading={revokingInvitationId === invitation.id}\n                      disabled={revokingInvitationId === invitation.id}\n                    >\n                      Eliminar\n                    </s-button>\n                  </s-stack>\n                );\n              })}\n            </s-stack>\n          )}\n          \n          {!showInviteForm ? (\n            <s-button \n              variant=\"primary\" \n              onClick={() => {\n                setShowInviteForm(true);\n                setInviteError(null);\n                setInviteSuccess(false);\n              }}\n            >\n              Invitar a alguien\n            </s-button>\n          ) : (\n            <s-stack direction=\"block\" gap=\"base\">\n              <s-heading>Invitar a un miembro</s-heading>\n              \n              {inviteSuccess && !inviteError && (\n                <s-banner tone=\"success\">\n                  <s-text>\u00A1Invitaci\u00F3n enviada exitosamente!</s-text>\n                </s-banner>\n              )}\n              \n              {inviteSuccess && inviteError && (\n                <s-banner tone=\"warning\">\n                  <s-text>Invitaci\u00F3n creada, pero el email no pudo ser enviado.</s-text>\n                  <s-text>{inviteError}</s-text>\n                  {inviteManualCode && (\n                    <s-stack direction=\"block\" gap=\"small\">\n                      <s-text>\n                        Comparte este c\u00F3digo manualmente: <s-text type=\"strong\">{inviteManualCode}</s-text>\n                      </s-text>\n                      <s-button\n                        variant=\"secondary\"\n                        onClick={() => copyInviteCode(inviteManualCode)}\n                        size=\"slim\"\n                      >\n                        Copiar c\u00F3digo\n                      </s-button>\n                      {copyMessage && (\n                        <s-text appearance=\"subdued\">{copyMessage}</s-text>\n                      )}\n                    </s-stack>\n                  )}\n                </s-banner>\n              )}\n              \n              {!inviteSuccess && inviteError && (\n                <s-banner tone=\"critical\">\n                  <s-text>{inviteError}</s-text>\n                </s-banner>\n              )}\n              \n              <s-text-field\n                label=\"Email del invitado\"\n                type=\"email\"\n                value={inviteEmail}\n                onChange={(e) => setInviteEmail(e.target.value)}\n                placeholder=\"ejemplo@email.com\"\n                disabled={sendingInvite}\n              />\n              \n              <s-stack direction=\"inline\" gap=\"base\" alignment=\"end\">\n                <s-button\n                  variant=\"secondary\"\n                  onClick={() => {\n                    setShowInviteForm(false);\n                    setInviteEmail('');\n                    setInviteError(null);\n                    setInviteSuccess(false);\n                    setInviteManualCode(null);\n                    setCopyMessage(null);\n                  }}\n                  disabled={sendingInvite}\n                >\n                  Cancelar\n                </s-button>\n                <s-button\n                  variant=\"primary\"\n                  onClick={handleInvite}\n                  loading={sendingInvite}\n                >\n                  Enviar Invitaci\u00F3n\n                </s-button>\n              </s-stack>\n            </s-stack>\n          )}\n        </s-stack>\n      </s-section>\n    );\n  }\n\n  if (groups.length === 0) {\n    return (\n      <s-section heading=\"Friends & Family\">\n        <s-stack direction=\"block\" gap=\"base\">\n          <s-text>No tienes grupos activos de Friends & Family.</s-text>\n          \n          {canCreateGroups ? (\n            !showCreateForm ? (\n              <s-button \n                variant=\"primary\" \n                onClick={() => {\n                  console.log('[ProfileBlock] Button clicked, showing form');\n                  setShowCreateForm(true);\n                }}\n              >\n                Crear un grupo\n              </s-button>\n            ) : (\n              <s-section>\n                <s-stack direction=\"block\" gap=\"base\">\n                  <s-heading>Crear Grupo Friends & Family</s-heading>\n                  \n                  {createGroupError && (\n                    <s-banner tone=\"critical\">\n                      <s-text>{createGroupError}</s-text>\n                    </s-banner>\n                  )}\n                  \n                  {maxMembersPerGroup && (\n                    <s-text appearance=\"subdued\">\n                      Tu grupo podr\u00E1 tener hasta {maxMembersPerGroup} miembros.\n                    </s-text>\n                  )}\n                  {!maxMembersPerGroup && (\n                    <s-text appearance=\"subdued\">\n                      El n\u00FAmero m\u00E1ximo de miembros se definir\u00E1 seg\u00FAn la configuraci\u00F3n del programa.\n                    </s-text>\n                  )}\n                  \n                  <s-text-field\n                    label=\"Nombre del Grupo\"\n                    value={groupName}\n                    onChange={(e) => setGroupName(e.target.value)}\n                    placeholder=\"Ej: Mi Familia\"\n                    disabled={creatingGroup}\n                  />\n                  \n                  <s-stack direction=\"inline\" gap=\"base\" alignment=\"end\">\n                    <s-button\n                      variant=\"secondary\"\n                      onClick={() => {\n                        setShowCreateForm(false);\n                        setCreateGroupError(null);\n                        setGroupName('');\n                      }}\n                      disabled={creatingGroup}\n                    >\n                      Cancelar\n                    </s-button>\n                    <s-button\n                      variant=\"primary\"\n                      onClick={createGroup}\n                      loading={creatingGroup}\n                    >\n                      Crear Grupo\n                    </s-button>\n                  </s-stack>\n                </s-stack>\n              </s-section>\n            )\n          ) : (\n            <s-section>\n              <s-stack direction=\"block\" gap=\"base\">\n                <s-heading>Unirse a un Grupo</s-heading>\n                <s-text appearance=\"subdued\">\n                  Ingresa el c\u00F3digo de invitaci\u00F3n que recibiste por email para unirte a un grupo de Friends & Family.\n                </s-text>\n                \n                {joinError && (\n                  <s-banner tone=\"critical\">\n                    <s-text>{joinError}</s-text>\n                  </s-banner>\n                )}\n                \n                <s-text-field\n                  label=\"C\u00F3digo de Invitaci\u00F3n\"\n                  value={inviteCode}\n                  onChange={(e) => setInviteCode(e.target.value)}\n                  placeholder=\"Ej: ABC12345\"\n                  disabled={joiningGroup}\n                />\n                \n                <s-button\n                  variant=\"primary\"\n                  onClick={joinGroupByCode}\n                  loading={joiningGroup}\n                >\n                  Unirse al Grupo\n                </s-button>\n                {joinSuccess && (\n                  <s-text appearance=\"positive\">\n                    \u00A1Te uniste correctamente! Actualizaremos tus grupos.\n                  </s-text>\n                )}\n              </s-stack>\n            </s-section>\n          )}\n        </s-stack>\n      </s-section>\n    );\n  }\n\n  return (\n    <s-section heading=\"Friends & Family\">\n      <s-stack direction=\"block\" gap=\"base\">\n        {groups.map((group) => (\n          <s-section key={group.id}>\n            <s-stack direction=\"block\" gap=\"small\">\n              <s-stack direction=\"inline\" justifyContent=\"space-between\" alignItems=\"center\">\n                <s-heading>{group.name}</s-heading>\n                <s-badge tone={group.status === 'active' ? 'success' : 'attention'}>\n                  {group.status === 'active' ? 'Activo' : group.status}\n                </s-badge>\n              </s-stack>\n              \n              <s-stack direction=\"block\" gap=\"small\">\n                <s-text>\n                  <s-text type=\"strong\">Miembros:</s-text> {group.current_members} / {group.max_members}\n                </s-text>\n                \n                {group.invite_code && (\n                  <s-text>\n                    <s-text type=\"strong\">C\u00F3digo de invitaci\u00F3n:</s-text> {group.invite_code}\n                  </s-text>\n                )}\n              </s-stack>\n              \n              <s-button \n                variant=\"primary\" \n                onClick={() => handleViewDetails(group)}\n              >\n                Ver detalles\n              </s-button>\n            </s-stack>\n          </s-section>\n        ))}\n        \n        {canCreateGroups && groups.length === 0 && (\n          !showCreateForm ? (\n            <s-button \n              variant=\"primary\" \n              onClick={() => {\n                console.log('[ProfileBlock] Button clicked, showing form');\n                setShowCreateForm(true);\n              }}\n            >\n              Crear nuevo grupo\n            </s-button>\n          ) : (\n            <s-section>\n              <s-stack direction=\"block\" gap=\"base\">\n                <s-heading>Crear Grupo Friends & Family</s-heading>\n                \n                {createGroupError && (\n                  <s-banner tone=\"critical\">\n                    <s-text>{createGroupError}</s-text>\n                  </s-banner>\n                )}\n                \n                {maxMembersPerGroup && (\n                  <s-text appearance=\"subdued\">\n                    Tu grupo podr\u00E1 tener hasta {maxMembersPerGroup} miembros.\n                  </s-text>\n                )}\n                {!maxMembersPerGroup && (\n                  <s-text appearance=\"subdued\">\n                    El n\u00FAmero m\u00E1ximo de miembros se definir\u00E1 seg\u00FAn la configuraci\u00F3n del programa.\n                  </s-text>\n                )}\n                \n                <s-text-field\n                  label=\"Nombre del Grupo\"\n                  value={groupName}\n                  onChange={(e) => setGroupName(e.target.value)}\n                  placeholder=\"Ej: Mi Familia\"\n                  disabled={creatingGroup}\n                />\n                \n                <s-stack direction=\"inline\" gap=\"base\" alignment=\"end\">\n                  <s-button\n                    variant=\"secondary\"\n                    onClick={() => {\n                      setShowCreateForm(false);\n                      setCreateGroupError(null);\n                      setGroupName('');\n                    }}\n                    disabled={creatingGroup}\n                  >\n                    Cancelar\n                  </s-button>\n                  <s-button\n                    variant=\"primary\"\n                    onClick={createGroup}\n                    loading={creatingGroup}\n                  >\n                    Crear Grupo\n                  </s-button>\n                </s-stack>\n              </s-stack>\n            </s-section>\n          )\n        )}\n      </s-stack>\n    </s-section>\n  );\n}\n", "import Target_0 from './src/ProfileBlock.jsx';shopify.extend('customer-account.profile.block.render', (...args) => Target_0(...args));\nimport Target_1 from './src/ProfileBlock.jsx';shopify.extend('customer-account.order-index.block.render', (...args) => Target_1(...args));"],
  "mappings": "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",
  "names": ["slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "CAPTURE_REGEX", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "__i", "__u", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "__i", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "__r", "prevDebounce", "options", "debounceRendering", "defer", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "l", "sort", "depthSort", "shift", "__v", "__P", "assign", "diff", "__n", "namespaceURI", "__u", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "result", "shouldPlace", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "Array", "constructor", "String", "createVNode", "isArray", "undefined", "__b", "key", "findMatchingIndex", "unmount", "parentVNode", "parentNode", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "x", "y", "childIndex", "key", "type", "oldVNode", "matched", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "lowerCaseName", "o", "cssText", "replace", "CAPTURE_REGEX", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "undefined", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "context", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "some", "vnode", "componentWillUpdate", "componentDidUpdate", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "Fragment", "cloneNode", "children", "diffChildren", "isArray", "base", "then", "MODE_HYDRATE", "nodeType", "nextSibling", "indexOf", "removeNode", "markAsForce", "diffElementNodes", "diffed", "forEach", "commitRoot", "root", "applyRef", "cb", "call", "node", "map", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "localName", "document", "createTextNode", "createElementNS", "is", "__m", "data", "childNodes", "EMPTY_OBJ", "attributes", "__html", "innerHTML", "content", "getDomSibling", "ref", "hasRefUnmount", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "replaceNode", "documentElement", "createElement", "namespaceURI", "firstChild", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "CAPTURE_REGEX", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useState", "initialState", "useReducer", "invokeOrReturn", "reducer", "init", "hookState", "_reducer", "action", "currentValue", "__N", "nextValue", "setState", "__f", "updateHookState", "p", "s", "c", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "props", "forEach", "hookItem", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "__s", "argsChanged", "_pendingArgs", "useRef", "initialValue", "currentHook", "useMemo", "current", "useMemo", "factory", "args", "state", "getHookState", "currentIndex", "argsChanged", "__H", "__", "__h", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "batch", "fn", "evalContext", "untracked", "prevContext", "globalVersion", "addDependency", "signal", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_subscribe", "Signal", "value", "options", "this", "_value", "_targets", "_watched", "watched", "_unwatched", "unwatched", "name", "prototype", "brand", "_refresh", "_this", "targets", "_this$_watched", "call", "_unsubscribe", "_this2", "prev", "_this2$_unwatched", "subscribe", "_this3", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "undefined", "_fn", "_globalVersion", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "finish", "_start", "bind", "_dispose", "dispose", "oldNotify", "currentComponent", "finishUpdate", "domQueue", "effect", "oldNotify", "this", "_notify", "hook", "hookName", "hookFn", "options", "bind", "setCurrentUpdater", "updater", "finishUpdate", "_start", "SignalValue", "_ref", "_this", "data", "currentSignal", "useSignal", "value", "_useMemo", "useMemo", "self", "v", "__v", "__", "__c", "_updateFlags", "wrappedSignal", "computed", "s", "isText", "Array", "isArray", "isValidElement", "dispose", "notifyDomUpdates", "__e", "nodeType", "oldDispose", "_updater", "_dispose", "call", "peek", "displayName", "Object", "defineProperties", "Signal", "prototype", "constructor", "configurable", "undefined", "type", "props", "get", "__b", "old", "vnode", "window", "__PREACT_SIGNALS_DEVTOOLS__", "exitComponent", "signalProps", "i", "__np", "enterComponent", "Fragment", "component", "update", "_callback", "setState", "createUpdater", "currentComponent", "error", "oldVNode", "dom", "renderedProps", "updaters", "_updaters", "prop", "signal", "createPropUpdater", "_update", "propSignal", "setAsProperty", "ownerSVGElement", "changeSignal", "newSignal", "newProps", "setAttribute", "removeAttribute", "index", "Component", "shouldComponentUpdate", "state", "hasSignals", "_sources", "__f", "u", "hasHooksState", "HAS_PENDING_UPDATE", "useState", "deferDomUpdates", "cb", "queueMicrotask", "flushDomUpdates", "batch", "inst", "domQueue", "shift", "oldNotify", "call", "notifyDomUpdates", "push", "this", "options", "requestAnimationFrame", "deferDomUpdates", "shopify", "u", "vnodeId", "createVNode", "type", "props", "key", "isStaticChildren", "__source", "__self", "ref", "i", "normalizedProps", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "vnodeId", "__i", "__u", "defaultProps", "options", "ProfileBlock_default", "__async", "G", "u", "FriendsFamilyBlock", "APP_URL", "groups", "setGroups", "d", "loading", "setLoading", "error", "setError", "canCreateGroups", "setCanCreateGroups", "maxMembersPerGroup", "setMaxMembersPerGroup", "showCreateForm", "setShowCreateForm", "creatingGroup", "setCreatingGroup", "createGroupError", "setCreateGroupError", "inviteCode", "setInviteCode", "joiningGroup", "setJoiningGroup", "joinError", "setJoinError", "joinSuccess", "setJoinSuccess", "selectedGroup", "setSelectedGroup", "groupDetails", "setGroupDetails", "loadingDetails", "setLoadingDetails", "showInviteForm", "setShowInviteForm", "inviteEmail", "setInviteEmail", "sendingInvite", "setSendingInvite", "inviteError", "setInviteError", "inviteSuccess", "setInviteSuccess", "inviteManualCode", "setInviteManualCode", "copyMessage", "setCopyMessage", "removingMemberId", "setRemovingMemberId", "removeError", "setRemoveError", "removeSuccess", "setRemoveSuccess", "revokingInvitationId", "setRevokingInvitationId", "revokeInvitationError", "setRevokeInvitationError", "groupDetailsRefreshIntervalRef", "A", "groupName", "setGroupName", "y", "fetchPermissions", "fetchGroups", "_a", "sessionToken", "authenticatedAccount", "customer", "apiUrl", "customerIdMatch", "response", "data", "err", "_b", "tokenError", "errorText", "errorMessage", "e", "fetchGroupDetails", "groupId", "handleViewDetails", "group", "handleBackToList", "handleRefreshGroupDetails", "handleRevokeInvitation", "invitationId", "url", "errorMsg", "handleInvite", "handleRemoveMember", "memberId", "createGroup", "joinGroupByCode", "copyInviteCode", "code", "members", "pendingInvitations", "member", "inv", "invitation", "isExpiringSoon", "args", "ProfileBlock_default"]
}
